# -*- coding: utf-8 -*-
"""RRT_basic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11Mq-sHsBe_AWxrb9yMTzKxn-nQtKxBIn
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle 
import random
from math import sqrt

starting_point=[]
for i in range(2):
 starting_point_c= float(input("Enter starting point- first x, then y: "))
 starting_point.append(starting_point_c)
goal_point=[]
for i in range(2):
 goal_point_c= float(input("Enter goal point- first x, then y: "))
 goal_point.append(goal_point_c)
incremental_distance= float(input("Enter incremental_distance: "))
n=int(input("Enter number of rectangular obstacles: "))
rows, cols= (n+1, 4)
rect=[[0 for i in range(cols)] for j in range(rows)] 
for i in range(1,n+1):
  print("Enter coordinates of obstacle "+ str(i) +" -first top right corner and then bottom left- x then y: ")
  for j in range(4):
    rect[i][j]=float(input())
k=int(input("Enter number of iterations: "))
r=float(input("Enter goal radius (tolerance): "))

def distance(p1, p2):
 d= sqrt((p2[1]-p1[1])**2+(p2[0]-p1[0])**2)
 return d

def computeCode(f, p, obs):
    x_max = obs[p][0]; 
    y_max = obs[p][1]; 
    x_min = obs[p][2]; 
    y_min = obs[p][3];
    code= (f[0] > x_min and f[0] < x_max and f[1] > y_min and f[1] < y_max)  
    return code

fig = plt.figure() 
ax = fig.add_subplot(111) 
for i in range (1,n+1):
 ax.add_patch( Rectangle((rect[i][0], rect[i][1]), 
                        rect[i][2]-rect[i][0], rect[i][3]-rect[i][1], 
                        fc ='none',  
                        ec ='g', 
                        lw = 3) )

plt.xlim([0, 15]) 
plt.ylim([0, 15]) 
plt.plot(starting_point[0],starting_point[1], 'ro')
plt.plot(goal_point[0],goal_point[1], 'ro')  
circle1= plt.Circle((starting_point[0],starting_point[1]), r, color='g')
circle2= plt.Circle((goal_point[0],goal_point[1]), r, color='g')  
ax.add_artist(circle1)
ax.add_artist(circle2)
rows1, cols1= (105, 2)
list_of_points=[[0 for i in range(cols1)] for j in range(rows1)] 
goal_min=[]
goal_max=[]
for i in range(2):
 list_of_points[0][i]=starting_point[i]
 goal_min_c=goal_point[i]-r
 goal_max_c=goal_point[i]+r
 goal_min.append(goal_min_c)
 goal_max.append(goal_max_c)

for i in range(1,k+1):
 dist=[]
 temp=[]
 nearest_point=[]
 random_point=[]
 for j in range(2):
   nearest_point_c= starting_point[j]
   random_point_c= float(random.randint(0,11))
   nearest_point.append(nearest_point_c)
   random_point.append(random_point_c)
 dist.append(distance(starting_point, random_point))
 for j in range(1,i):                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
   dist.append(distance(list_of_points[j], random_point))
   if dist[j]<dist[j-1]:
     for l in range(2):
       nearest_point[l]=list_of_points[j][l]
 if nearest_point[0]==random_point[0]:
   slope= 57
 else:
   slope=(random_point[1]-nearest_point[1])/(random_point[0]-nearest_point[0])
 
 for o in range(1,n+1):
  b=1
  a=0.01
  while a<=incremental_distance:
    temp=[]
    a=b*0.01
    temp.append((a/sqrt(1+slope*slope))+nearest_point[0])
    temp.append(slope*(temp[0]-nearest_point[0])+nearest_point[1])
    c=computeCode(temp, o, rect);
    if c==True:
      break
    else:
     b=b+1
  if c==True:
    break
 if c==True:
   continue
 elif c!=True:
   for j in range(2):
    list_of_points[i][j]=temp[j]
    plt.plot([nearest_point[0],temp[0]],[nearest_point[1],temp[1]] )
plt.show()

for i in range(1,k+1):
  if list_of_points[i][0]>goal_min[0] and list_of_points[i][0]<goal_max[0] and list_of_points[i][1]>goal_min[1] and list_of_points[i][1]<goal_max[1]:
    print("Goal Reached!")
  else:
    print("Goal still not reached")

